.text
start:
.globl start
call main
finish:
mv a1, a0 # a1 = a0 
li a0, 17 # a0 = 17
ecall # выход с кодом завершения


.text
main:
.globl main

  addi sp, sp, -16 # выделение памяти в стеке
  sw ra, 12(sp) # сохранение ra 
  la a3, input_string 
  la a6, output
  andi a6, a6, 0xFFFFFFFC
  addi a6, a6, 4

  call edsac 

  lw ra, 12(sp) # восстановление ra
  addi sp, sp, 16 # освобождение памяти в стеке

  li a0, 0 # a0 = 0
  ret # return 

.data
dictionary:
  .word 0x01510050, 0x03450257, 0x05540452, 0x07550659, 0x094F0849, 0x0b230a4a, 0x0d5a0c53, 0x0f210e4b, 0x1146102e, 0x13441240, 0x15481421, 0x174d164e, 0x194c1826, 0x1b471a58, 0x1d421c41, 0x1f561e43
input_string:
  .string "V 12 L P 8 S Q 64 L Q 64 L "
output:  

.text
edsac:
.globl edsac 
# a0 - во время исполнения программы там формируются промежуточные результаты,
#а после исполнения сюда кладётся адрес начиная с которого будут записаны результаты
#a1 - регистр для посимвольного прохода по словарю
#а после исполнения сюда кладётся адрес первого свободного бита
#a2 - регистр для посимвольного прохода по инпуту
#a3 - адрес input_string (передаётся как аргумент)
#a4 - указатель для посимвольного прохода по инпуту
#a5 - указатель для посимвольного прохода по словарю
#a6 - адрес output (передаётся как аргумент)
#t0 - константа - ascii код пробела
#t1 - константа - ascii код буквы L
#t2 - регистр для формирования числа, которое находится между буквами
#t3 - вспомогательный для t2
#t4 - указатель для записи результатов
#

  li t0, 0x20  
  li t1, 0x4c 
  lb a2, a3, 0
  addi a4, a3, 0
  addi t4, a6, 0
  loop: 
  la a5, dictionary 
  li t2, 0
    loop1: # считываем первый символ
      lb a1, a5, 0  
      addi a5, a5, 2 
      bne a2, a1, loop1 
      lb a0, a5, -1 #пишем в а0 5 бит означающих в эдсаке первый символ
      slli a0, a0, 11
    loop1_exit:
    addi a4, a4, 1
    loop2: # считываем число
      #считываем следующий символ инпута
      lb a2, a4, 0
      #если пробел, считываем ещё один
      bne a2, t0, else
      addi a4, a4, 1
      lb a2, a4, 0
      else:#если не пробел то умножаем t2 на 10 
      #и прибавляем к t2 ещё число из инпута
      #умножаем t2 на 10 
      beq t2, x0, read_new
      addi t3, t2, 0 #положили t2 в t3
      slli t3, t3, 2 #сдвинули
      add t3, t3, t2 #опять прибавили t2 в t3
      slli t3, t3, 1 #сдвинули
      addi t2, t3, 0 #положили в t2 результат
      read_new:
      #прибавляем к t2 ещё число из инпута
      add t2, t2, a2
      addi t2, t2, -48 #скорректировали ascii
      #считываем следующий символ
      #если не пробел, то идем в else
      addi a4, a4, 1
      lb a2, a4, 0
      bne a2, t0, else
      add a0, a0, t2
      slli a0, a0, 1
    loop2_exit:
    #Считывание последнего символа
    loop3:
    addi a4, a4, 1
    lb a2, a4, 0
    bne a2, t1, not_l
    addi a0, a0, 1 
    not_l:
    addi a4, a4, 2
    lb a2, a4, 0
    sw a0, 0(t4)
    addi t4, t4, 4 
    bne a2, x0, loop
  loop_exit:
  addi a0, a6, 0
  addi a1, t4, 0 
  ret